body Pi

  import Geometrie;  
  import Barriere;

  bool DEBUG = false;       # Pour trace de debogage
  #DEBUG = true;  

  ##################################################################
  # Variables et operations pour la manipulation du sac de taches.
  ##################################################################

  sem mutex = 1;

  # Variables pour representer le sac de taches.
  int restant;
  int tailleTache = 100;
  
  procedure prendreTache()
  {
    P( mutex );
    restant -= tailleTache;
    V( mutex );
  }

  proc definirTailleTache( tt )
  { tailleTache = tt; }

  # Initialisation du sac de taches.
  procedure initSacDeTaches( int nbTaches )
  {
      if(nbTaches % tailleTache != 0) {
          printf("Le nombre de tâches doit être divisible par la taille du sac de tâches");
          stop(1);
      }
      restant = nbTaches;
  }

  # Retrait d'une tache du sac.
  procedure obtenirTache() returns bool disponible 
  {
      prendreTache();
      disponible = (restant > 0);
  }

  ##################################################
  # Autres operations auxiliaires.
  ##################################################

  external getenv(string[*]) returns string[2];

  procedure getNbProcs() returns int nbProcs
  {
     nbProcs = 1;
     if (getenv("MPD_PARALLEL") != "") {
       nbProcs = int(getenv("MPD_PARALLEL"));
    }
  }

  procedure calculPI(int nbPtsDansCercle, int nbPoints) returns real r
  {
    r = 4*(real(nbPtsDansCercle)/nbPoints);
  }

  ##################################################
  # Version sequentielle.
  ##################################################

  proc calculS( nbPoints ) returns r
  {  
     int nbPtsDansCercle = 0;

     # Création des points et vérfication de position
     for [i = 1 to nbPoints] {
        Point p = initialiserPoint();
	    if (estDansCercle(p)) {
	        nbPtsDansCercle++;
        }	     
        free(p);
     }
     
     # Calcul de PI
     r = calculPI(nbPtsDansCercle, nbPoints);        
  }

  ##################################################
  # Version parallele iterative granularite fine.
  ##################################################
   
  procedure traiterPointFin(ref int listeNbPoints[*], int i) 
  {
     Point p = initialiserPoint();
     if (estDansCercle(p)) {
        listeNbPoints[i] = 1;
     }
     free(p);
  }

  proc calculPIF( nbPoints ) returns r
  {
     int listeNbPoints[nbPoints] = ([nbPoints] 0);
     int nbPtsDansCercle = 0;
    
     # Création des points et vérfication de position
     co [i = 1 to nbPoints]
        traiterPointFin(listeNbPoints, i);	      
     oc  

     for [j = 1 to nbPoints] {
        if (listeNbPoints[j] > 0)
        {
           nbPtsDansCercle += listeNbPoints[j];
        }
     }
     
     # Calcul de PI
     r = calculPI(nbPtsDansCercle, nbPoints); 
  }


  ##################################################
  # Version parallele iterative granularite grossiere.
  ##################################################

  #cap Barriere barriere;
  sem totLibre = 1;   # Semaphore protegeant l'acces à nbPointsDansCercle

  procedure traiterPointGros() returns bool estInclus 
  {
     Point p = initialiserPoint();
     estInclus = estDansCercle(p);
     free(p);
  }

  procedure traitementThread(int nbPointsThread, ref int nbPointsDansCercle)
  {
     int nbPtsThreadInclus = 0;
     for [j = 1 to nbPointsThread]
     {
        if (traiterPointGros())
        {
           nbPtsThreadInclus++;
        }
     }
     #barriere.attendre();
     P(totLibre); nbPointsDansCercle += nbPtsThreadInclus; V(totLibre);
  }

  proc calculPIGA( nbPoints ) returns r
  {
     int nbPtsDansCercle = 0;
     int nbProcs = getNbProcs();

     # Création des points et vérfication de position
     co [i = 1 to nbProcs]
        traitementThread(nbPoints/nbProcs, nbPtsDansCercle);	      
     oc  
     
     # Calcul de PI
     r = calculPI(nbPtsDansCercle, nbPoints);  
  }

  ##################################################
  # Version parallele sac de taches.
  ##################################################

  procedure executerTache(ref int nbPtsDansCercle)
  {
      while(obtenirTache()) {
          traitementThread(tailleTache, nbPtsDansCercle);
      }
  }

  proc calculPST( nbPoints) returns r
  {
     int nbPtsDansCercle = 0;
      
     initSacDeTaches(nbPoints);

     co[i = 1 to getNbProcs()]
         executerTache(nbPtsDansCercle);
     oc

     r = calculPI(nbPtsDansCercle, nbPoints);
  }
end
