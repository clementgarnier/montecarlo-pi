body Pi

  import Geometrie;

  bool DEBUG = false;       # Pour trace de debogage
  #DEBUG = true;  
 
  ##################################################################
  # Variables et operations pour la manipulation du sac de taches.
  ##################################################################

  sem mutex = 1;

  procedure FA( ref int x, int incr ) returns int r
  {
    P( mutex );
    r = x;
    x += incr;
    V( mutex )
  }

  int tailleTache = 10;

  proc definirTailleTache( tt )
  { tailleTache = tt; }

  # Variables pour representer le sac de taches.
  int suivant, borneSup;

  # Initialisation du sac de taches.
  procedure initSacDeTaches( int bi, int bs )
  { suivant = bi; borneSup = bs;  }

  # Retrait d'une tache du sac.
  procedure obtenirTache( res int i, res int j ) returns bool disponible 
  {
    i = FA( suivant, tailleTache );
    j = min( i + tailleTache - 1, borneSup );
    disponible = (i <= borneSup);
  }

  ##################################################
  # Autres operations auxiliaires.
  ##################################################

  external getenv(string[*]) returns string[2];

  procedure getNbProcs() returns int nbProcs
  {
     nbProcs = 1;
     if (getenv("MPD_PARALLEL") != "") {
      nbProcs = int(getenv("MPD_PARALLEL"));
    }
  }

  ##################################################
  # Version sequentielle.
  ##################################################

  proc calculS( nbPoints ) returns r
  {  
     int nbPtsDansCercle = 0;

     # Création des points et vérfication de position
     for [i = 1 to nbPoints] {
        Point p = initialiserPoint();
	if (estDansCercle(p)) {
	   nbPtsDansCercle++;
        }	      
     }  
     
     # Calcul de PI
     r = 4*nbPtsDansCercle/nbPoints;        
  }

  ##################################################
  # Version parallele iterative granularite fine.
  ##################################################
  
  procedure traiterPoint(int listeNbPoints[*], int i) 
  {
     Point p = initialiserPoint();
     if (estDansCercle(p))
     {
	listeNbPoints[i] = 1;
     }
  }

  proc calculPIF( nbPoints ) returns r
  {
     int listeNbPoints[nbPoints] = ([nbPoints] 0);
     int nbPtsDansCercle = 0;

     # Création des points et vérfication de position
     co [i = 1 to nbPoints]
        traiterPoint(listeNbPoints, i);	      
     oc  

     for [j = 1 to nbPoints] {
        if (listeNbPoints[j] > 0)
        {
           nbPtsDansCercle += listeNbPoints[j]
        }
     }
     
     # Calcul de PI
     r = 4*nbPtsDansCercle/nbPoints; 
  }


  ##################################################
  # Version parallele iterative granularite grossiere.
  ##################################################

  proc calculPIGA( nbPoints) returns pi
  {
  }

  ##################################################
  # Version parallele iterative granularite grossiere, distribution cyclique.
  ##################################################

  proc calculPIGC( nbPoints) returns pi
  {
  }

  ##################################################
  # Version parallele sac de taches.
  ##################################################

  proc calculPST( nbPoints) returns r
  { 
  }
end
