body Pi

  import Geometrie;  
  import Barriere;

  bool DEBUG = false;       # Pour trace de debogage
  #DEBUG = true;  

  ##################################################################
  # Variables et operations pour la manipulation du sac de taches.
  ##################################################################

  sem mutex = 1;

  procedure FA( ref int x, int incr ) returns int r
  {
    P( mutex );
    r = x;
    x += incr;
    V( mutex )
  }

  int tailleTache = 10;

  proc definirTailleTache( tt )
  { tailleTache = tt; }

  # Variables pour representer le sac de taches.
  int suivant, borneSup;

  # Initialisation du sac de taches.
  procedure initSacDeTaches( int bi, int bs )
  { suivant = bi; borneSup = bs;  }

  # Retrait d'une tache du sac.
  procedure obtenirTache( res int i, res int j ) returns bool disponible 
  {
    i = FA( suivant, tailleTache );
    j = min( i + tailleTache - 1, borneSup );
    disponible = (i <= borneSup);
  }

  ##################################################
  # Autres operations auxiliaires.
  ##################################################

  external getenv(string[*]) returns string[2];

  procedure getNbProcs() returns int nbProcs
  {
     nbProcs = 1;
     if (getenv("MPD_PARALLEL") != "") {
       nbProcs = int(getenv("MPD_PARALLEL"));
    }
  }

  procedure calculPI(int nbPtsDansCercle, int nbPoints) returns real r
  {
    r = 4*(real(nbPtsDansCercle)/nbPoints);
  }

  ##################################################
  # Version sequentielle.
  ##################################################

  proc calculS( nbPoints ) returns r
  {  
     int nbPtsDansCercle = 0;

     # Création des points et vérfication de position
     for [i = 1 to nbPoints] {
        Point p = initialiserPoint();
	    if (estDansCercle(p)) 
        {
	        nbPtsDansCercle++;
        }	      
     }  
     
     # Calcul de PI
     r = calculPI(nbPtsDansCercle, nbPoints);        
  }

  ##################################################
  # Version parallele iterative granularite fine.
  ##################################################
   
  procedure traiterPointFin(ref int listeNbPoints[*], int i) 
  {
     Point p = initialiserPoint();
     if (estDansCercle(p))
     {
        listeNbPoints[i] = 1;
     }
  }

  proc calculPIF( nbPoints ) returns r
  {
     int listeNbPoints[nbPoints] = ([nbPoints] 0);
     int nbPtsDansCercle = 0;
    
     # Création des points et vérfication de position
     co [i = 1 to nbPoints]
        traiterPointFin(listeNbPoints, i);	      
     oc  

     for [j = 1 to nbPoints] {
        if (listeNbPoints[j] > 0)
        {
           nbPtsDansCercle += listeNbPoints[j];
        }
     }
     
     # Calcul de PI
     r = calculPI(nbPtsDansCercle, nbPoints); 
  }


  ##################################################
  # Version parallele iterative granularite grossiere.
  ##################################################

  #cap Barriere barriere;
  sem totLibre = 1;   # Semaphore protegeant l'acces à nbPointsDansCercle

  procedure traiterPointGros() returns bool estInclus 
  {
     Point p = initialiserPoint();
     estInclus = estDansCercle(p);
  }

  procedure traitementThread(int nbPointsThread, ref int nbPointsDansCercle)
  {
     int nbPtsThreadInclus = 0;
     for [j = 1 to nbPointsThread]
     {
        if (traiterPointGros())
        {
           nbPtsThreadInclus += 1;
        }
     }
     #barriere.attendre();
     P(totLibre); nbPointsDansCercle += nbPtsThreadInclus; V(totLibre);
  }

  proc calculPIGA( nbPoints ) returns r
  {
     int nbPtsDansCercle = 0;
     int nbProcs = getNbProcs();

     # Création des points et vérfication de position
     co [i = 1 to nbProcs]
        traitementThread(nbPoints/nbProcs, nbPtsDansCercle);	      
     oc  
     
     # Calcul de PI
     r = calculPI(nbPtsDansCercle, nbPoints);  
  }

  ##################################################
  # Version parallele sac de taches.
  ##################################################

  proc calculPST( nbPoints) returns r
  { 
  }
end
